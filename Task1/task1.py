# -*- coding: utf-8 -*-
"""Task1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x5nSo08MQgjO4WcoJG11SUMbW3rqYmBe
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline

# Commented out IPython magic to ensure Python compatibility.
# %cd '/content/drive/MyDrive/Datasets '

!wget 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'

df = pd.read_csv('iris.data')

df

df['Iris-setosa'].value_counts()

#Replace the flowers with their one-hot encodes
flowers = {
    'Iris-virginica': 0,
    'Iris-versicolor': 1,
    'Iris-setosa': 2
}
df['Iris-setosa'].replace(flowers,inplace=True)

#Load the data into numpy arrays
x = np.array(df.loc[:,'5.1':'0.2'])
y = np.array(df['Iris-setosa'])

#Reshape the arrays
x = x.reshape(-1,4)
y = y.reshape(-1,1)

#Make train and test datasets
n_test = 30
shuffled_indices = np.random.permutation(df.shape[0])

x_train = x[shuffled_indices[n_test:]]
y_train = y[shuffled_indices[n_test:]]

x_test = x[shuffled_indices[:n_test]]
y_test = y[shuffled_indices[:n_test]]

x_train.shape

#Define the distance function
def euclideanDistance(x,value):
  '''value : Set for which we want to calculate the distance'''
  square_distance = np.sum(np.power((value - x),2),axis=1)
  return np.sqrt(square_distance)

per_class_predictions = [0,0,0]
for k in range(0,50):
  val = y_train[np.argsort(euclideanDistance(x_train,x_test[0])) == k].item()
  per_class_predictions[val]+=1

#Define the predictor function 
def predict(euclidDistance,y,k):
  per_class_predictions = [0,0,0]
  flower_array = np.array([0,1,2])
  arg_sort = np.argsort(euclidDistance)
  for k in range(0,k):
    val = y[np.argsort(euclidDistance) == k].item()
    per_class_predictions[val] += 1
  final_sort = np.argsort(np.array(per_class_predictions))
  return flower_array[(np.argsort(np.array(per_class_predictions)) == 2)].item()

predictions = []
for i in x_test:
  distance = euclideanDistance(x_train,i)
  predictions.append(predict(distance,y_train,k=30))

#Calculate the accuracy
preds = (np.array(predictions).reshape(30,1) == y_test).sum()
print("Accuracy of model: {}".format(100*preds/y_test.shape[0]))

from sklearn.linear_model import LinearRegression

model = LinearRegression()

model.fit(x_train,y_train)

preds_linear = model.predict(x_test)

#Calculate accuracy
preds_final = np.full_like(preds_linear,0)
preds_final[preds_linear < 0.5] = 0 
preds_final[(preds_linear < 1.5)*(preds_linear>0.5)] = 1
preds_final[preds_linear > 1.5] = 2
print("Accuracy of model: {}".format(100*np.sum((preds_final==y_test))/y_test.shape[0]))